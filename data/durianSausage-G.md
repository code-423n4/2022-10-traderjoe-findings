### G01: COMPARISONS WITH ZERO FOR UNSIGNED INTEGERS
#### problem
0 is less gas efficient than !0 if you enable the optimizer at 10k AND you’re in a require statement. Detailed explanation with the opcodes https://twitter.com/gzeon/status/1485428085885640706
#### prof
LBFactory.sol, 161, b'            if (_nbPresets > 0) {'
LBFactory.sol, 191, b'            if (_nbAvailable > 0) {'
LBQuoter.sol, 79, b'            if (quote.pairs[i] != address(0) && quote.amounts[i] > 0) {'
LBQuoter.sol, 82, b'                if (reserveIn > 0 && reserveOut > 0) {'
LBQuoter.sol, 82, b'                if (reserveIn > 0 && reserveOut > 0) {'
LBQuoter.sol, 99, b'            if (LBPairsAvailable.length > 0 && quote.amounts[i] > 0) {'
LBQuoter.sol, 99, b'            if (LBPairsAvailable.length > 0 && quote.amounts[i] > 0) {'
LBQuoter.sol, 154, b'        for (uint256 i = swapLength; i > 0; i--) {'
LBQuoter.sol, 157, b'            if (quote.pairs[i - 1] != address(0) && quote.amounts[i] > 0) {'
LBQuoter.sol, 160, b'                if (reserveIn > 0 && reserveOut > quote.amounts[i]) {'
LBQuoter.sol, 176, b'            if (LBPairsAvailable.length > 0 && quote.amounts[i] > 0) {'
LBQuoter.sol, 176, b'            if (LBPairsAvailable.length > 0 && quote.amounts[i] > 0) {'

### G02: PREFIX INCREMENT SAVE MORE GAS
#### problem
prefix increment ++i is more cheaper than postfix i++
#### prof
LBRouter.sol, 711, b'        for (uint256 i = _pairs.length; i != 0; i--) {'
LBQuoter.sol, 100, b'                for (uint256 j; j < LBPairsAvailable.length; j++) {'
LBQuoter.sol, 75, b'        for (uint256 i; i < swapLength; i++) {'
LBQuoter.sol, 177, b'                for (uint256 j; j < LBPairsAvailable.length; j++) {'
LBQuoter.sol, 154, b'        for (uint256 i = swapLength; i > 0; i--) {'

### G03: X += Y COSTS MORE GAS THAN X = X + Y FOR STATE VARIABLES
#### prof
LBToken.sol, 211, b'        _totalSupplies[_id] += _amount;'
LBToken.sol, 241, b'            _totalSupplies[_id] -= _amount;'


### G04: USING BOOLS FOR STORAGE INCURS OVERHEAD
#### problem
// Booleans are more expensive than uint256 or any type that takes up a full
// word because each write operation emits an extra SLOAD to first read the
// slot's contents, replace the bits taken up by the boolean, and then write
// back. This is the compiler's defense against contract upgrades and
// pointer aliasing, and it cannot be disabled.
#### prof
LBToken.sol, 21, b'    mapping(address => mapping(address => bool)) private _spenderApprovals;'


### G05: ++I/I++ SHOULD BE UNCHECKED{++I}/UNCHECKED{I++} WHEN IT IS NOT POSSIBLE FOR THEM TO OVERFLOW, AS IS THE CASE WHEN USED IN FOR- AND WHILE-LOOPS
#### problem
The unchecked keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves 30-40 gas per loop
#### prof
LBFactory.sol, 168, b'                        if (++_index == _nbPresets) break;'
LBFactory.sol, 165, b'                for (uint256 i = MIN_BIN_STEP; i <= MAX_BIN_STEP; ++i) {'
LBFactory.sol, 205, b'                        if (++_index == _nbAvailable) break;'
LBFactory.sol, 195, b'                for (uint256 i = MIN_BIN_STEP; i <= MAX_BIN_STEP; ++i) {'
LBRouter.sol, 674, b'            for (uint256 i; i < depositIds.length; ++i) {'
LBRouter.sol, 711, b'        for (uint256 i = _pairs.length; i != 0; i--) {'
LBRouter.sol, 778, b'            for (uint256 i; i < _pairs.length; ++i) {'
LBRouter.sol, 831, b'            for (uint256 i; i < _pairs.length; ++i) {'
LBRouter.sol, 878, b'            for (uint256 i; i < _pairs.length; ++i) {'
LBRouter.sol, 951, b'            for (uint256 i; i < pairs.length; ++i) {'
LBToken.sol, 90, b'            for (uint256 i; i < _accounts.length; ++i) {'
LBToken.sol, 163, b'            for (uint256 i; i < _ids.length; ++i) {'
LBQuoter.sol, 100, b'                for (uint256 j; j < LBPairsAvailable.length; j++) {'
LBQuoter.sol, 75, b'        for (uint256 i; i < swapLength; i++) {'
LBQuoter.sol, 177, b'                for (uint256 j; j < LBPairsAvailable.length; j++) {'
LBQuoter.sol, 154, b'        for (uint256 i = swapLength; i > 0; i--) {'


### G06：ABI.ENCODE() IS LESS EFFICIENT THAN ABI.ENCODEPACKED()
#### prof
LBFactory.sol, 265, b'        bytes32 _salt = keccak256(abi.encode(_tokenA, _tokenB, _binStep));'

### G07: FUNCTIONS GUARANTEED TO REVERT WHEN CALLED BY NORMAL USERS CAN BE MARKED PAYABLE
#### problem
If a function modifier such as onlyOwner is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are CALLVALUE(2),DUP1(3),ISZERO(3),PUSH2(3),JUMPI(10),PUSH1(3),DUP1(3),REVERT(0),JUMPDEST(1),POP(2), which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost
#### prof
LBFactory.sol, 211, b'    function getAllLBPairs(IERC20 _tokenX, IERC20 _tokenY)\n        external\n        view\n        override\n        returns (LBPairInformation[] memory LBPairsAvailable)\n    '
LBFactory.sol, 227, b'    function setLBPairImplementation(address _LBPairImplementation) external override onlyOwner '
LBFactory.sol, 306, b'    function createLBPair(\n        IERC20 _tokenX,\n        IERC20 _tokenY,\n        uint24 _activeId,\n        uint16 _binStep\n    ) external override returns (ILBPair _LBPair) '
LBFactory.sol, 329, b'    function setLBPairIgnored(\n        IERC20 _tokenX,\n        IERC20 _tokenY,\n        uint256 _binStep,\n        bool _ignored\n    ) external override onlyOwner '
LBFactory.sol, 393, b'    function setPreset(\n        uint16 _binStep,\n        uint16 _baseFactor,\n        uint16 _filterPeriod,\n        uint16 _decayPeriod,\n        uint16 _reductionFactor,\n        uint24 _variableFeeControl,\n        uint16 _protocolShare,\n        uint24 _maxVolatilityAccumulated,\n        uint16 _sampleLifetime\n    ) external override onlyOwner '
LBFactory.sol, 411, b'    function removePreset(uint16 _binStep) external override onlyOwner '
LBFactory.sol, 465, b'    function setFeesParametersOnPair(\n        IERC20 _tokenX,\n        IERC20 _tokenY,\n        uint16 _binStep,\n        uint16 _baseFactor,\n        uint16 _filterPeriod,\n        uint16 _decayPeriod,\n        uint16 _reductionFactor,\n        uint24 _variableFeeControl,\n        uint16 _protocolShare,\n        uint24 _maxVolatilityAccumulated\n    ) external override onlyOwner '
LBFactory.sol, 471, b'    function setFeeRecipient(address _feeRecipient) external override onlyOwner '
LBFactory.sol, 482, b'    function setFlashLoanFee(uint256 _flashLoanFee) external override onlyOwner '
LBFactory.sol, 490, b'    function setFactoryLockedState(bool _locked) external override onlyOwner '
LBFactory.sol, 499, b'    function addQuoteAsset(IERC20 _quoteAsset) external override onlyOwner '
LBFactory.sol, 507, b'    function removeQuoteAsset(IERC20 _quoteAsset) external override onlyOwner '
LBFactory.sol, 523, b'    function forceDecay(ILBPair _LBPair) external override onlyOwner '
LBRouter.sol, 634, b'    function sweep(\n        IERC20 _token,\n        address _to,\n        uint256 _amount\n    ) external override onlyFactoryOwner '
LBRouter.sol, 634, b'    function sweep(\n        IERC20 _token,\n        address _to,\n        uint256 _amount\n    ) external override onlyFactoryOwner '
LBRouter.sol, 649, b'    function sweepLBToken(\n        ILBToken _lbToken,\n        address _to,\n        uint256[] memory _ids,\n        uint256[] memory _amounts\n    ) external override onlyFactoryOwner '
LBRouter.sol, 649, b'    function sweepLBToken(\n        ILBToken _lbToken,\n        address _to,\n        uint256[] memory _ids,\n        uint256[] memory _amounts\n    ) external override onlyFactoryOwner '
LBToken.sol, 117, b'    function isApprovedForAll(address _owner, address _spender) public view virtual override returns (bool) '
LBToken.sol, 117, b'    function isApprovedForAll(address _owner, address _spender) public view virtual override returns (bool) '
LBToken.sol, 262, b'    function _setApprovalForAll(\n        address _owner,\n        address _spender,\n        bool _approved\n    ) internal virtual '
LBToken.sol, 262, b'    function _setApprovalForAll(\n        address _owner,\n        address _spender,\n        bool _approved\n    ) internal virtual '
LBToken.sol, 271, b'    function _isApprovedForAll(address _owner, address _spender) internal view virtual returns (bool) '
LBToken.sol, 271, b'    function _isApprovedForAll(address _owner, address _spender) internal view virtual returns (bool) '
libraries/TokenHelper.sol, 34, b'    function safeTransferFrom(\n        IERC20 token,\n        address owner,\n        address recipient,\n        uint256 amount\n    ) internal '
libraries/TokenHelper.sol, 34, b'    function safeTransferFrom(\n        IERC20 token,\n        address owner,\n        address recipient,\n        uint256 amount\n    ) internal '
libraries/PendingOwnable.sol, 49, b'    function owner() public view override returns (address) '
libraries/PendingOwnable.sol, 49, b'    function owner() public view override returns (address) '
libraries/PendingOwnable.sol, 55, b'    function pendingOwner() public view override returns (address) '
libraries/PendingOwnable.sol, 55, b'    function pendingOwner() public view override returns (address) '
libraries/PendingOwnable.sol, 63, b'    function setPendingOwner(address pendingOwner_) public override onlyOwner '
libraries/PendingOwnable.sol, 63, b'    function setPendingOwner(address pendingOwner_) public override onlyOwner '
libraries/PendingOwnable.sol, 71, b'    function revokePendingOwner() public override onlyOwner '
libraries/PendingOwnable.sol, 71, b'    function revokePendingOwner() public override onlyOwner '
libraries/PendingOwnable.sol, 77, b'    function becomeOwner() public override onlyPendingOwner '
libraries/PendingOwnable.sol, 77, b'    function becomeOwner() public override onlyPendingOwner '
libraries/PendingOwnable.sol, 86, b'    function renounceOwnership() public override onlyOwner '
libraries/PendingOwnable.sol, 86, b'    function renounceOwnership() public override onlyOwner '
libraries/PendingOwnable.sol, 96, b'    function _transferOwnership(address _newOwner) internal virtual '
libraries/PendingOwnable.sol, 96, b'    function _transferOwnership(address _newOwner) internal virtual '
libraries/PendingOwnable.sol, 104, b'    function _setPendingOwner(address pendingOwner_) internal virtual '
libraries/PendingOwnable.sol, 104, b'    function _setPendingOwner(address pendingOwner_) internal virtual '

### G08: USING PRIVATE RATHER THAN PUBLIC FOR CONSTANTS, SAVES GAS
#### problem:
We can save getter function of public constants.
#### prof:
LBFactory.sol, 25, b'    uint256 public constant override MAX_FEE = 0.1e18; // 10%'
LBFactory.sol, 27, b'    uint256 public constant override MIN_BIN_STEP = 1; // 0.01%'
LBFactory.sol, 28, b"    uint256 public constant override MAX_BIN_STEP = 100; // 1%, can't be greater than 247 for indexing reasons"
LBFactory.sol, 30, b'    uint256 public constant override MAX_PROTOCOL_SHARE = 2_500; // 25%'
LBRouter.sol, 28, b'    ILBFactory public immutable override factory;'
LBRouter.sol, 29, b'    IJoeFactory public immutable override oldFactory;'
LBRouter.sol, 30, b'    IWAVAX public immutable override wavax;'
LBQuoter.sol, 21, b'    address public immutable routerV2;'
LBQuoter.sol, 23, b'    address public immutable factoryV1;'
LBQuoter.sol, 25, b'    address public immutable factoryV2;'

### G09: USAGE OF UINTS/INTS SMALLER THAN 32 BYTES (256 BITS) INCURS OVERHEAD
#### problem
When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.
#### prof
LBFactory.sol, 93, b'        return _quoteAssetWhitelist.contains(address(_token));'
LBFactory.sol, 136, b'        if (_preset == bytes32(0)) revert LBFactory__BinStepHasNoPreset(_binStep);'
LBFactory.sol, 141, b'        assert(_binStep == _preset.decode(type(uint16).max, _shift));'
LBFactory.sol, 141, b'        assert(_binStep == _preset.decode(type(uint16).max, _shift));'
LBFactory.sol, 141, b'        assert(_binStep == _preset.decode(type(uint16).max, _shift));'
LBFactory.sol, 141, b'        assert(_binStep == _preset.decode(type(uint16).max, _shift));'
LBFactory.sol, 159, b'            uint256 _nbPresets = _avPresets.decode(type(uint8).max, 248);'
LBFactory.sol, 159, b'            uint256 _nbPresets = _avPresets.decode(type(uint8).max, 248);'
LBFactory.sol, 159, b'            uint256 _nbPresets = _avPresets.decode(type(uint8).max, 248);'
LBFactory.sol, 159, b'            uint256 _nbPresets = _avPresets.decode(type(uint8).max, 248);'
LBFactory.sol, 161, b'            if (_nbPresets > 0) {'
LBFactory.sol, 166, b'                    if (_avPresets.decode(1, i) == 1) {'
LBFactory.sol, 166, b'                    if (_avPresets.decode(1, i) == 1) {'
LBFactory.sol, 189, b'            uint256 _nbAvailable = _avLBPairBinSteps.decode(type(uint8).max, 248);'
LBFactory.sol, 189, b'            uint256 _nbAvailable = _avLBPairBinSteps.decode(type(uint8).max, 248);'
LBFactory.sol, 189, b'            uint256 _nbAvailable = _avLBPairBinSteps.decode(type(uint8).max, 248);'
LBFactory.sol, 189, b'            uint256 _nbAvailable = _avLBPairBinSteps.decode(type(uint8).max, 248);'
LBFactory.sol, 191, b'            if (_nbAvailable > 0) {'
LBFactory.sol, 196, b'                    if (_avLBPairBinSteps.decode(1, i) == 1) {'
LBFactory.sol, 196, b'                    if (_avLBPairBinSteps.decode(1, i) == 1) {'
LBFactory.sol, 245, b'        if (_LBPairImplementation == address(0)) revert LBFactory__ImplementationNotSet();'
LBFactory.sol, 254, b'        if (address(_tokenA) == address(0)) revert LBFactory__AddressZero();'
LBFactory.sol, 255, b'        if (address(_LBPairsInfo[_tokenA][_tokenB][_binStep].LBPair) != address(0))'
LBFactory.sol, 259, b'        if (_preset == bytes32(0)) revert LBFactory__BinStepHasNoPreset(_binStep);'
LBFactory.sol, 261, b'        uint256 _sampleLifetime = _preset.decode(type(uint16).max, 240);'
LBFactory.sol, 261, b'        uint256 _sampleLifetime = _preset.decode(type(uint16).max, 240);'
LBFactory.sol, 261, b'        uint256 _sampleLifetime = _preset.decode(type(uint16).max, 240);'
LBFactory.sol, 261, b'        uint256 _sampleLifetime = _preset.decode(type(uint16).max, 240);'
LBFactory.sol, 265, b'        bytes32 _salt = keccak256(abi.encode(_tokenA, _tokenB, _binStep));'
LBFactory.sol, 268, b'        _LBPair.initialize(_tokenX, _tokenY, _activeId, uint16(_sampleLifetime), _preset);'
LBFactory.sol, 268, b'        _LBPair.initialize(_tokenX, _tokenY, _activeId, uint16(_sampleLifetime), _preset);'
LBFactory.sol, 268, b'        _LBPair.initialize(_tokenX, _tokenY, _activeId, uint16(_sampleLifetime), _preset);'
LBFactory.sol, 268, b'        _LBPair.initialize(_tokenX, _tokenY, _activeId, uint16(_sampleLifetime), _preset);'
LBFactory.sol, 277, b'        allLBPairs.push(_LBPair);'
LBFactory.sol, 321, b'        if (address(_LBPairInformation.LBPair) == address(0)) revert LBFactory__AddressZero();'
LBFactory.sol, 351, b'        bytes32 _packedFeeParameters = _getPackedFeeParameters('
LBFactory.sol, 352, b'            _binStep,'
LBFactory.sol, 353, b'            _baseFactor,'
LBFactory.sol, 354, b'            _filterPeriod,'
LBFactory.sol, 355, b'            _decayPeriod,'
LBFactory.sol, 356, b'            _reductionFactor,'
LBFactory.sol, 357, b'            _variableFeeControl,'
LBFactory.sol, 358, b'            _protocolShare,'
LBFactory.sol, 360, b'            _maxVolatilityAccumulated\n        );'
LBFactory.sol, 370, b'        if (_avPresets.decode(1, _binStep) == 0) {'
LBFactory.sol, 370, b'        if (_avPresets.decode(1, _binStep) == 0) {'
LBFactory.sol, 370, b'        if (_avPresets.decode(1, _binStep) == 0) {'
LBFactory.sol, 397, b'        if (_presets[_binStep] == bytes32(0)) revert LBFactory__BinStepHasNoPreset(_binStep);'
LBFactory.sol, 435, b'        ILBPair _LBPair = _getLBPairInformation(_tokenX, _tokenY, _binStep).LBPair;'
LBFactory.sol, 437, b'        if (address(_LBPair) == address(0)) revert LBFactory__LBPairNotCreated(_tokenX, _tokenY, _binStep);'
LBFactory.sol, 439, b'        bytes32 _packedFeeParameters = _getPackedFeeParameters('
LBFactory.sol, 440, b'            _binStep,'
LBFactory.sol, 441, b'            _baseFactor,'
LBFactory.sol, 442, b'            _filterPeriod,'
LBFactory.sol, 443, b'            _decayPeriod,'
LBFactory.sol, 444, b'            _reductionFactor,'
LBFactory.sol, 445, b'            _variableFeeControl,'
LBFactory.sol, 446, b'            _protocolShare,'
LBFactory.sol, 448, b'            _maxVolatilityAccumulated\n        );'
LBFactory.sol, 511, b'        if (_feeRecipient == address(0)) revert LBFactory__AddressZero();'
LBFactory.sol, 543, b'        if (_binStep < MIN_BIN_STEP || _binStep > MAX_BIN_STEP)'
LBFactory.sol, 543, b'        if (_binStep < MIN_BIN_STEP || _binStep > MAX_BIN_STEP)'
LBFactory.sol, 546, b'        if (_baseFactor > Constants.BASIS_POINT_MAX)'
LBFactory.sol, 549, b'        if (_filterPeriod >= _decayPeriod) revert LBFactory__DecreasingPeriods(_filterPeriod, _decayPeriod);'
LBFactory.sol, 549, b'        if (_filterPeriod >= _decayPeriod) revert LBFactory__DecreasingPeriods(_filterPeriod, _decayPeriod);'
LBFactory.sol, 551, b'        if (_reductionFactor > Constants.BASIS_POINT_MAX)'
LBFactory.sol, 554, b'        if (_protocolShare > MAX_PROTOCOL_SHARE)'
LBFactory.sol, 558, b'            uint256 _baseFee = (uint256(_baseFactor) * _binStep) * 1e10;'
LBFactory.sol, 563, b'            uint256 _prod = uint256(_maxVolatilityAccumulated) * _binStep;'
LBFactory.sol, 563, b'            uint256 _prod = uint256(_maxVolatilityAccumulated) * _binStep;'
LBFactory.sol, 564, b'            uint256 _maxVariableFee = (_prod * _prod * _variableFeeControl) / 100;'
LBFactory.sol, 575, b'                    uint136(_maxVolatilityAccumulated), // The first 112 bits are reserved for the dynamic parameters'
LBFactory.sol, 575, b'                    uint136(_maxVolatilityAccumulated), // The first 112 bits are reserved for the dynamic parameters'
LBFactory.sol, 575, b'                    uint136(_maxVolatilityAccumulated), // The first 112 bits are reserved for the dynamic parameters'
LBFactory.sol, 576, b'                    _protocolShare,'
LBFactory.sol, 577, b'                    _variableFeeControl,'
LBFactory.sol, 578, b'                    _reductionFactor,'
LBFactory.sol, 579, b'                    _decayPeriod,'
LBFactory.sol, 580, b'                    _filterPeriod,'
LBFactory.sol, 581, b'                    _baseFactor,'
LBFactory.sol, 583, b'                    _binStep\n                )'
LBRouter.sol, 73, b'        return BinHelper.getIdFromPrice(_price, _LBPair.feeParameters().binStep);'
LBRouter.sol, 73, b'        return BinHelper.getIdFromPrice(_price, _LBPair.feeParameters().binStep);'
LBRouter.sol, 81, b'        return BinHelper.getPriceFromId(_id, _LBPair.feeParameters().binStep);'
LBRouter.sol, 81, b'        return BinHelper.getPriceFromId(_id, _LBPair.feeParameters().binStep);'
LBRouter.sol, 97, b'        if (_amountOut == 0 || (_swapForY ? _amountOut > _pairReserveY : _amountOut > _pairReserveX))'
LBRouter.sol, 111, b'                (uint256 _reserveX, uint256 _reserveY) = _LBPair.getBin(uint24(_activeId));'
LBRouter.sol, 111, b'                (uint256 _reserveX, uint256 _reserveY) = _LBPair.getBin(uint24(_activeId));'
LBRouter.sol, 114, b'            uint256 _price = BinHelper.getPriceFromId(_activeId, _fp.binStep);'
LBRouter.sol, 115, b'            if (_reserve != 0) {'
LBRouter.sol, 127, b'                if (_amountInWithFees + _reserve > type(uint112).max) revert LBRouter__SwapOverflows(_activeId);'
LBRouter.sol, 127, b'                if (_amountInWithFees + _reserve > type(uint112).max) revert LBRouter__SwapOverflows(_activeId);'
LBRouter.sol, 127, b'                if (_amountInWithFees + _reserve > type(uint112).max) revert LBRouter__SwapOverflows(_activeId);'
LBRouter.sol, 133, b'            if (_amountOut != 0) {'
LBRouter.sol, 139, b'        if (_amountOut != 0) revert LBRouter__BrokenSwapSafetyCheck(); // Safety check, but should never be false as it would have reverted on transfer'
LBRouter.sol, 164, b'                (uint256 _reserveX, uint256 _reserveY) = _LBPair.getBin(uint24(_activeId));'
LBRouter.sol, 164, b'                (uint256 _reserveX, uint256 _reserveY) = _LBPair.getBin(uint24(_activeId));'
LBRouter.sol, 167, b'            if (_bin.reserveX != 0 || _bin.reserveY != 0) {'
LBRouter.sol, 167, b'            if (_bin.reserveX != 0 || _bin.reserveY != 0) {'
LBRouter.sol, 167, b'            if (_bin.reserveX != 0 || _bin.reserveY != 0) {'
LBRouter.sol, 167, b'            if (_bin.reserveX != 0 || _bin.reserveY != 0) {'
LBRouter.sol, 171, b'                if (_amountInToBin > type(uint112).max) revert LBRouter__BinReserveOverflows(_activeId);'
LBRouter.sol, 171, b'                if (_amountInToBin > type(uint112).max) revert LBRouter__BinReserveOverflows(_activeId);'
LBRouter.sol, 171, b'                if (_amountInToBin > type(uint112).max) revert LBRouter__BinReserveOverflows(_activeId);'
LBRouter.sol, 178, b'            if (_amountIn != 0) {'
LBRouter.sol, 184, b'        if (_amountIn != 0) revert LBRouter__TooMuchTokensIn(_amountIn);'
LBRouter.sol, 285, b'        ILBPair _LBPair = _getLBPairInformation(_tokenX, _tokenY, _binStep);'
LBRouter.sol, 318, b'        ILBPair _LBPair = _getLBPairInformation(_token, IERC20(wavax), _binStep);'
LBRouter.sol, 627, b'        if (address(_token) == address(0)) {'
LBRouter.sol, 665, b'            if (_liq.activeIdDesired > type(uint24).max || _liq.idSlippage > type(uint24).max)'
LBRouter.sol, 665, b'            if (_liq.activeIdDesired > type(uint24).max || _liq.idSlippage > type(uint24).max)'
LBRouter.sol, 665, b'            if (_liq.activeIdDesired > type(uint24).max || _liq.idSlippage > type(uint24).max)'
LBRouter.sol, 665, b'            if (_liq.activeIdDesired > type(uint24).max || _liq.idSlippage > type(uint24).max)'
LBRouter.sol, 665, b'            if (_liq.activeIdDesired > type(uint24).max || _liq.idSlippage > type(uint24).max)'
LBRouter.sol, 665, b'            if (_liq.activeIdDesired > type(uint24).max || _liq.idSlippage > type(uint24).max)'
LBRouter.sol, 676, b'                if (_id < 0 || uint256(_id) > type(uint24).max) revert LBRouter__IdOverflows(_id);'
LBRouter.sol, 676, b'                if (_id < 0 || uint256(_id) > type(uint24).max) revert LBRouter__IdOverflows(_id);'
LBRouter.sol, 676, b'                if (_id < 0 || uint256(_id) > type(uint24).max) revert LBRouter__IdOverflows(_id);'
LBRouter.sol, 676, b'                if (_id < 0 || uint256(_id) > type(uint24).max) revert LBRouter__IdOverflows(_id);'
LBRouter.sol, 711, b'        for (uint256 i = _pairs.length; i != 0; i--) {'
LBRouter.sol, 717, b'            if (_binStep == 0) {'
LBRouter.sol, 718, b'                (uint256 _reserveIn, uint256 _reserveOut, ) = IJoePair(_pair).getReserves();'
LBRouter.sol, 718, b'                (uint256 _reserveIn, uint256 _reserveOut, ) = IJoePair(_pair).getReserves();'
LBRouter.sol, 787, b'                if (_binStep == 0) {'
LBRouter.sol, 788, b'                    (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();'
LBRouter.sol, 788, b'                    (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();'
LBRouter.sol, 795, b'                        IJoePair(_pair).swap(amountOut, 0, _recipient, "");'
LBRouter.sol, 792, b'                        IJoePair(_pair).swap(0, amountOut, _recipient, "");'
LBRouter.sol, 840, b'                if (_binStep == 0) {'
LBRouter.sol, 845, b'                        IJoePair(_pair).swap(amountOut, 0, _recipient, "");'
LBRouter.sol, 843, b'                        IJoePair(_pair).swap(0, amountOut, _recipient, "");'
LBRouter.sol, 887, b'                if (_binStep == 0) {'
LBRouter.sol, 888, b'                    (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();'
LBRouter.sol, 888, b'                    (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();'
LBRouter.sol, 898, b'                        IJoePair(_pair).swap(_amountOut, 0, _recipient, "");'
LBRouter.sol, 893, b'                        IJoePair(_pair).swap(0, _amountOut, _recipient, "");'
LBRouter.sol, 919, b'        if (address(_LBPair) == address(0))'
LBRouter.sol, 935, b'        if (_binStep == 0) {'
LBRouter.sol, 937, b'            if (_pair == address(0)) revert LBRouter__PairNotCreated(address(_tokenX), address(_tokenY), _binStep);'
LBToken.sol, 27, b'    mapping(address => EnumerableSet.UintSet) private _userIds;'
LBToken.sol, 101, b'        return _userIds[_account].at(_index);'
LBToken.sol, 108, b'        return _userIds[_account].length();'
LBToken.sol, 207, b'        if (_account == address(0)) revert LBToken__MintToAddress0();'
LBToken.sol, 209, b'        _beforeTokenTransfer(address(0), _account, _id, _amount);'
LBToken.sol, 232, b'        if (_account == address(0)) revert LBToken__BurnFromAddress0();'
LBToken.sol, 237, b'        _beforeTokenTransfer(address(0), _account, _id, _amount);'
LBToken.sol, 284, b'        if (_accountBalance == 0 && _amount != 0) {'
LBToken.sol, 284, b'        if (_accountBalance == 0 && _amount != 0) {'
LBToken.sol, 285, b'            _userIds[_account].add(_id);'
LBToken.sol, 300, b'        if (_accountBalance == _amount && _amount != 0) {'
LBToken.sol, 301, b'            _userIds[_account].remove(_id);'
LBQuoter.sol, 59, b'        if (_route.length < 2) {'
LBQuoter.sol, 65, b'        uint256 swapLength = _route.length - 1;'
LBQuoter.sol, 79, b'            if (quote.pairs[i] != address(0) && quote.amounts[i] > 0) {'
LBQuoter.sol, 79, b'            if (quote.pairs[i] != address(0) && quote.amounts[i] > 0) {'
LBQuoter.sol, 82, b'                if (reserveIn > 0 && reserveOut > 0) {'
LBQuoter.sol, 82, b'                if (reserveIn > 0 && reserveOut > 0) {'
LBQuoter.sol, 99, b'            if (LBPairsAvailable.length > 0 && quote.amounts[i] > 0) {'
LBQuoter.sol, 99, b'            if (LBPairsAvailable.length > 0 && quote.amounts[i] > 0) {'
LBQuoter.sol, 139, b'        if (_route.length < 2) {'
LBQuoter.sol, 144, b'        uint256 swapLength = _route.length - 1;'
LBQuoter.sol, 154, b'        for (uint256 i = swapLength; i > 0; i--) {'
LBQuoter.sol, 157, b'            if (quote.pairs[i - 1] != address(0) && quote.amounts[i] > 0) {'
LBQuoter.sol, 157, b'            if (quote.pairs[i - 1] != address(0) && quote.amounts[i] > 0) {'
LBQuoter.sol, 160, b'                if (reserveIn > 0 && reserveOut > quote.amounts[i]) {'
LBQuoter.sol, 176, b'            if (LBPairsAvailable.length > 0 && quote.amounts[i] > 0) {'
LBQuoter.sol, 176, b'            if (LBPairsAvailable.length > 0 && quote.amounts[i] > 0) {'
LBQuoter.sol, 223, b'        (uint256 reserve0, uint256 reserve1, ) = IJoePair(_pair).getReserves();'
LBQuoter.sol, 223, b'        (uint256 reserve0, uint256 reserve1, ) = IJoePair(_pair).getReserves();'
libraries/TokenHelper.sol, 27, b'        if (amount != 0) {'
libraries/TokenHelper.sol, 45, b'        if (amount != 0) {'
libraries/PendingOwnable.sol, 60, b'        if (pendingOwner_ == address(0)) revert PendingOwnable__AddressZero();'
libraries/PendingOwnable.sol, 61, b'        if (_pendingOwner != address(0)) revert PendingOwnable__PendingOwnerAlreadySet();'
libraries/PendingOwnable.sol, 69, b'        if (_pendingOwner == address(0)) revert PendingOwnable__NoPendingOwner();'
libraries/PendingOwnable.sol, 70, b'        _setPendingOwner(address(0));'
libraries/PendingOwnable.sol, 85, b'        _transferOwnership(address(0));'
libraries/Math512Bits.sol, 61, b'        if (offset > 255) revert Math512Bits__OffsetOverflows(offset);'
libraries/Math512Bits.sol, 65, b'        if (prod0 != 0) result = prod0 >> offset;'
libraries/Math512Bits.sol, 66, b'        if (prod1 != 0) {'
libraries/Math512Bits.sol, 68, b'            if (prod1 >= 1 << offset) revert Math512Bits__MulShiftOverflow(prod1, offset);'
libraries/Math512Bits.sol, 99, b'            if (mulmod(x, y, 1 << offset) != 0) result += 1;'
libraries/Math512Bits.sol, 99, b'            if (mulmod(x, y, 1 << offset) != 0) result += 1;'
libraries/Math512Bits.sol, 124, b'        if (offset > 255) revert Math512Bits__OffsetOverflows(offset);'
libraries/Math512Bits.sol, 133, b'        return _getEndOfDivRoundDown(x, 1 << offset, denominator, prod0, prod1);'
libraries/Math512Bits.sol, 159, b'            if (mulmod(x, 1 << offset, denominator) != 0) result += 1;'
libraries/Math512Bits.sol, 159, b'            if (mulmod(x, 1 << offset, denominator) != 0) result += 1;'
libraries/Math512Bits.sol, 194, b'        if (prod1 == 0) {'
libraries/Math512Bits.sol, 235, b'                uint256 inverse = (3 * denominator) ^ 2;'
libraries/FeeDistributionHelper.sol, 31, b'        uint128 _totalFees = _pairFees.total;'
libraries/FeeDistributionHelper.sol, 31, b'        uint128 _totalFees = _pairFees.total;'
libraries/FeeDistributionHelper.sol, 31, b'        uint128 _totalFees = _pairFees.total;'
libraries/FeeDistributionHelper.sol, 32, b'        uint256 _amountReceived = _token.received(_reserve, _totalFees);'
libraries/FeeDistributionHelper.sol, 34, b'        if (_fees.total > _amountReceived)'
libraries/FeeDistributionHelper.sol, 37, b'        _fees.total = _amountReceived.safe128();'
libraries/FeeDistributionHelper.sol, 39, b'        _pairFees.total = _totalFees + _fees.total;'
libraries/FeeDistributionHelper.sol, 42, b'            _pairFees.protocol += _fees.protocol;'
libraries/BitMath.sol, 21, b'        } else return closestBitLeft(_integer, _bit + 1);'
libraries/BitMath.sol, 21, b'        } else return closestBitLeft(_integer, _bit + 1);'
libraries/BitMath.sol, 21, b'        } else return closestBitLeft(_integer, _bit + 1);'
libraries/BitMath.sol, 20, b'            return closestBitRight(_integer, _bit - 1);'
libraries/BitMath.sol, 20, b'            return closestBitRight(_integer, _bit - 1);'
libraries/BitMath.sol, 20, b'            return closestBitRight(_integer, _bit - 1);'
libraries/BitMath.sol, 31, b'        } else return leastSignificantBit(_integer);'
libraries/BitMath.sol, 30, b'            return mostSignificantBit(_integer);'
libraries/BitMath.sol, 41, b'            uint256 _shift = 255 - bit;'
libraries/BitMath.sol, 41, b'            uint256 _shift = 255 - bit;'
libraries/BitMath.sol, 41, b'            uint256 _shift = 255 - bit;'
libraries/BitMath.sol, 44, b'            if (x == 0) return type(uint256).max;'
libraries/BitMath.sol, 47, b'            return mostSignificantBit(x) - _shift;'
libraries/BitMath.sol, 60, b'            if (x == 0) return type(uint256).max;'
libraries/BitMath.sol, 62, b'            return leastSignificantBit(x) + bit;'
libraries/BitMath.sol, 62, b'            return leastSignificantBit(x) + bit;'
libraries/BitMath.sol, 62, b'            return leastSignificantBit(x) + bit;'
libraries/BitMath.sol, 71, b'            if (x >= 1 << 128) {'
libraries/BitMath.sol, 71, b'            if (x >= 1 << 128) {'
libraries/BitMath.sol, 71, b'            if (x >= 1 << 128) {'
libraries/BitMath.sol, 73, b'                msb = 128;'
libraries/BitMath.sol, 75, b'            if (x >= 1 << 64) {'
libraries/BitMath.sol, 75, b'            if (x >= 1 << 64) {'
libraries/BitMath.sol, 75, b'            if (x >= 1 << 64) {'
libraries/BitMath.sol, 77, b'                msb += 64;'
libraries/BitMath.sol, 79, b'            if (x >= 1 << 32) {'
libraries/BitMath.sol, 79, b'            if (x >= 1 << 32) {'
libraries/BitMath.sol, 79, b'            if (x >= 1 << 32) {'
libraries/BitMath.sol, 81, b'                msb += 32;'
libraries/BitMath.sol, 83, b'            if (x >= 1 << 16) {'
libraries/BitMath.sol, 83, b'            if (x >= 1 << 16) {'
libraries/BitMath.sol, 83, b'            if (x >= 1 << 16) {'
libraries/BitMath.sol, 85, b'                msb += 16;'
libraries/BitMath.sol, 87, b'            if (x >= 1 << 8) {'
libraries/BitMath.sol, 87, b'            if (x >= 1 << 8) {'
libraries/BitMath.sol, 89, b'                msb += 8;'
libraries/BitMath.sol, 91, b'            if (x >= 1 << 4) {'
libraries/BitMath.sol, 91, b'            if (x >= 1 << 4) {'
libraries/BitMath.sol, 91, b'            if (x >= 1 << 4) {'
libraries/BitMath.sol, 93, b'                msb += 4;'
libraries/BitMath.sol, 95, b'            if (x >= 1 << 2) {'
libraries/BitMath.sol, 95, b'            if (x >= 1 << 2) {'
libraries/BitMath.sol, 95, b'            if (x >= 1 << 2) {'
libraries/BitMath.sol, 97, b'                msb += 2;'
libraries/BitMath.sol, 99, b'            if (x >= 1 << 1) {'
libraries/BitMath.sol, 99, b'            if (x >= 1 << 1) {'
libraries/BitMath.sol, 99, b'            if (x >= 1 << 1) {'
libraries/BitMath.sol, 100, b'                msb += 1;'
libraries/BitMath.sol, 110, b'            if (x << 128 != 0) {'
libraries/BitMath.sol, 110, b'            if (x << 128 != 0) {'
libraries/BitMath.sol, 112, b'                lsb = 128;'
libraries/BitMath.sol, 114, b'            if (x << 64 != 0) {'
libraries/BitMath.sol, 114, b'            if (x << 64 != 0) {'
libraries/BitMath.sol, 116, b'                lsb += 64;'
libraries/BitMath.sol, 118, b'            if (x << 32 != 0) {'
libraries/BitMath.sol, 118, b'            if (x << 32 != 0) {'
libraries/BitMath.sol, 120, b'                lsb += 32;'
libraries/BitMath.sol, 122, b'            if (x << 16 != 0) {'
libraries/BitMath.sol, 122, b'            if (x << 16 != 0) {'
libraries/BitMath.sol, 124, b'                lsb += 16;'
libraries/BitMath.sol, 126, b'            if (x << 8 != 0) {'
libraries/BitMath.sol, 126, b'            if (x << 8 != 0) {'
libraries/BitMath.sol, 128, b'                lsb += 8;'
libraries/BitMath.sol, 130, b'            if (x << 4 != 0) {'
libraries/BitMath.sol, 130, b'            if (x << 4 != 0) {'
libraries/BitMath.sol, 132, b'                lsb += 4;'
libraries/BitMath.sol, 134, b'            if (x << 2 != 0) {'
libraries/BitMath.sol, 134, b'            if (x << 2 != 0) {'
libraries/BitMath.sol, 136, b'                lsb += 2;'
libraries/BitMath.sol, 138, b'            if (x << 1 != 0) {'
libraries/BitMath.sol, 138, b'            if (x << 1 != 0) {'
libraries/BitMath.sol, 139, b'                lsb += 1;'
libraries/BitMath.sol, 142, b'            return 255 - lsb;'
libraries/BitMath.sol, 142, b'            return 255 - lsb;'
libraries/BitMath.sol, 142, b'            return 255 - lsb;'
libraries/SwapHelper.sol, 46, b'        uint256 _price = BinHelper.getPriceFromId(activeId, fp.binStep);'
libraries/SwapHelper.sol, 61, b'        if (_maxAmountInToBin + fees.total <= amountIn) {'
libraries/SwapHelper.sol, 88, b'        pairFees.total += fees.total;'
libraries/SwapHelper.sol, 91, b'            pairFees.protocol += fees.protocol;'
libraries/SwapHelper.sol, 123, b'            bin.reserveY += amountInToBin;'
libraries/SwapHelper.sol, 126, b'                bin.reserveX -= amountOutOfBin;'
libraries/SwapHelper.sol, 127, b'                pair.reserveX -= uint136(amountOutOfBin);'
libraries/SwapHelper.sol, 128, b'                pair.reserveY += uint136(amountInToBin);'
libraries/SwapHelper.sol, 115, b'            bin.reserveX += amountInToBin;'
libraries/SwapHelper.sol, 118, b'                bin.reserveY -= amountOutOfBin;'
libraries/SwapHelper.sol, 119, b'                pair.reserveX += uint136(amountInToBin);'
libraries/SwapHelper.sol, 120, b'                pair.reserveY -= uint136(amountOutOfBin);'
libraries/Math128x128.sol, 41, b'        if (x == 1) return 0;'
libraries/Math128x128.sol, 41, b'        if (x == 1) return 0;'
libraries/Math128x128.sol, 42, b'        if (x == 0) revert Math128x128__LogUnderflow();'
libraries/Math128x128.sol, 58, b'            uint256 n = (x >> LOG_SCALE_OFFSET).mostSignificantBit();'
libraries/Math128x128.sol, 71, b'                for (int256 delta = int256(1 << (LOG_SCALE_OFFSET - 1)); delta > 0; delta >>= 1) {'
libraries/Math128x128.sol, 75, b'                    if (y >= 1 << (LOG_SCALE_OFFSET + 1)) {'
libraries/Math128x128.sol, 71, b'                for (int256 delta = int256(1 << (LOG_SCALE_OFFSET - 1)); delta > 0; delta >>= 1) {'
libraries/Math128x128.sol, 98, b'        if (y == 0) return Constants.SCALE;'
libraries/Math128x128.sol, 108, b'        if (absY < 0x100000) {'
libraries/Math128x128.sol, 200, b'        if (result == 0) revert Math128x128__PowerUnderflow(x, y);'
libraries/Oracle.sol, 48, b'        if (_activeSize == 0) revert Oracle__NotInitialized();'
libraries/Oracle.sol, 60, b'        if (_activeSize != 1) {'
libraries/Oracle.sol, 118, b'        if (block.timestamp - _lastTimestamp >= _sampleLifetime && _lastTimestamp != 0) {'
libraries/Oracle.sol, 152, b'        uint256 _low = 1;'
libraries/ReentrancyGuardUpgradeable.sol, 32, b'        if (_status != 0) revert ReentrancyGuardUpgradeable__AlreadyInitialized();'
libraries/BinHelper.sol, 29, b'            if (_id < 0 || uint256(_id) > type(uint24).max) revert BinHelper__IdOverflows(_id);'
libraries/BinHelper.sol, 29, b'            if (_id < 0 || uint256(_id) > type(uint24).max) revert BinHelper__IdOverflows(_id);'
libraries/BinHelper.sol, 29, b'            if (_id < 0 || uint256(_id) > type(uint24).max) revert BinHelper__IdOverflows(_id);'
libraries/BinHelper.sol, 29, b'            if (_id < 0 || uint256(_id) > type(uint24).max) revert BinHelper__IdOverflows(_id);'
libraries/BinHelper.sol, 30, b'            return uint24(uint256(_id));'
libraries/BinHelper.sol, 30, b'            return uint24(uint256(_id));'
libraries/BinHelper.sol, 52, b'        if (_binStep == 0 || _binStep > Constants.BASIS_POINT_MAX) revert BinHelper__BinStepOverflows(_binStep);'
libraries/FeeHelper.sol, 56, b'        uint256 _deltaT = block.timestamp - _fp.time;'
libraries/FeeHelper.sol, 58, b'        if (_deltaT >= _fp.filterPeriod || _fp.time == 0) {'
libraries/FeeHelper.sol, 58, b'        if (_deltaT >= _fp.filterPeriod || _fp.time == 0) {'
libraries/FeeHelper.sol, 58, b'        if (_deltaT >= _fp.filterPeriod || _fp.time == 0) {'
libraries/FeeHelper.sol, 59, b'            _fp.indexRef = uint24(_activeId);'
libraries/FeeHelper.sol, 60, b'            if (_deltaT < _fp.decayPeriod) {'
libraries/FeeHelper.sol, 68, b'                _fp.volatilityReference = 0;'
libraries/FeeHelper.sol, 65, b'                    _fp.volatilityReference = uint24(\n                        (uint256(_fp.reductionFactor) * _fp.volatilityAccumulated) / Constants.BASIS_POINT_MAX\n                    );'
libraries/FeeHelper.sol, 72, b'        _fp.time = (block.timestamp).safe40();'
libraries/FeeHelper.sol, 82, b'            _fp.volatilityReference;'
libraries/FeeHelper.sol, 85, b'        _fp.volatilityAccumulated = volatilityAccumulated > _fp.maxVolatilityAccumulated\n            ? _fp.maxVolatilityAccumulated\n            : uint24(volatilityAccumulated);'
libraries/FeeHelper.sol, 93, b'            return uint256(_fp.baseFactor) * _fp.binStep * 1e10;'
libraries/FeeHelper.sol, 93, b'            return uint256(_fp.baseFactor) * _fp.binStep * 1e10;'
libraries/FeeHelper.sol, 93, b'            return uint256(_fp.baseFactor) * _fp.binStep * 1e10;'
libraries/FeeHelper.sol, 101, b'        if (_fp.variableFeeControl != 0) {'
libraries/FeeHelper.sol, 101, b'        if (_fp.variableFeeControl != 0) {'
libraries/FeeHelper.sol, 106, b'                uint256 _prod = uint256(_fp.volatilityAccumulated) * _fp.binStep;'
libraries/FeeHelper.sol, 106, b'                uint256 _prod = uint256(_fp.volatilityAccumulated) * _fp.binStep;'
libraries/FeeHelper.sol, 147, b'        fees.total = _fees.safe128();'
libraries/FeeHelper.sol, 150, b'            fees.protocol = uint128((_fees * _fp.protocolShare) / Constants.BASIS_POINT_MAX);'
libraries/JoeLibrary.sol, 15, b'        if (token0 == address(0)) revert JoeLibrary__AddressZero();'
libraries/JoeLibrary.sol, 24, b'        if (amountA == 0) revert JoeLibrary__InsufficientAmount();'
libraries/JoeLibrary.sol, 25, b'        if (reserveA == 0 || reserveB == 0) revert JoeLibrary__InsufficientLiquidity();'
libraries/JoeLibrary.sol, 25, b'        if (reserveA == 0 || reserveB == 0) revert JoeLibrary__InsufficientLiquidity();'
libraries/JoeLibrary.sol, 35, b'        if (amountIn == 0) revert JoeLibrary__InsufficientAmount();'
libraries/JoeLibrary.sol, 36, b'        if (reserveIn == 0 || reserveOut == 0) revert JoeLibrary__InsufficientLiquidity();'
libraries/JoeLibrary.sol, 36, b'        if (reserveIn == 0 || reserveOut == 0) revert JoeLibrary__InsufficientLiquidity();'
libraries/JoeLibrary.sol, 37, b'        uint256 amountInWithFee = amountIn * 997;'
libraries/JoeLibrary.sol, 39, b'        uint256 denominator = reserveIn * 1000 + amountInWithFee;'
libraries/JoeLibrary.sol, 49, b'        if (amountOut == 0) revert JoeLibrary__InsufficientAmount();'
libraries/JoeLibrary.sol, 50, b'        if (reserveIn == 0 || reserveOut == 0) revert JoeLibrary__InsufficientLiquidity();'
libraries/JoeLibrary.sol, 50, b'        if (reserveIn == 0 || reserveOut == 0) revert JoeLibrary__InsufficientLiquidity();'
libraries/JoeLibrary.sol, 51, b'        uint256 numerator = reserveIn * amountOut * 1000;'
libraries/JoeLibrary.sol, 52, b'        uint256 denominator = (reserveOut - amountOut) * 997;'
libraries/Samples.sol, 58, b'            return pack(_cumulativeBinCrossed, _cumulativeVolatilityAccumulated, _cumulativeId, block.timestamp, 1);'
libraries/TreeMath.sol, 38, b'                    return _getBottomId(_binId, uint24(bit));'
libraries/TreeMath.sol, 38, b'                    return _getBottomId(_binId, uint24(bit));'
libraries/TreeMath.sol, 38, b'                    return _getBottomId(_binId, uint24(bit));'
libraries/TreeMath.sol, 38, b'                    return _getBottomId(_binId, uint24(bit));'
libraries/TreeMath.sol, 38, b'                    return _getBottomId(_binId, uint24(bit));'
libraries/TreeMath.sol, 50, b'                    _binId = _getBottomId(_binId, uint24(bit));'
libraries/TreeMath.sol, 53, b'                    return _getBottomId(_binId, current.significantBit(_rightSide));'
libraries/TreeMath.sol, 53, b'                    return _getBottomId(_binId, current.significantBit(_rightSide));'
libraries/TreeMath.sol, 53, b'                    return _getBottomId(_binId, current.significantBit(_rightSide));'
libraries/TreeMath.sol, 53, b'                    return _getBottomId(_binId, current.significantBit(_rightSide));'
libraries/TreeMath.sol, 63, b'            _binId = _getBottomId(uint24(bit), current.significantBit(_rightSide));'
libraries/TreeMath.sol, 66, b'            return _getBottomId(_binId, current.significantBit(_rightSide));'
libraries/TreeMath.sol, 66, b'            return _getBottomId(_binId, current.significantBit(_rightSide));'
libraries/TreeMath.sol, 66, b'            return _getBottomId(_binId, current.significantBit(_rightSide));'
libraries/TreeMath.sol, 66, b'            return _getBottomId(_binId, current.significantBit(_rightSide));'
libraries/TreeMath.sol, 72, b'        uint256 _idDepth2 = _id >> 8;'
libraries/TreeMath.sol, 73, b'        uint256 _idDepth1 = _id >> 16;'
libraries/TreeMath.sol, 83, b'            uint256 _idDepth2 = _id >> 8;'
libraries/TreeMath.sol, 87, b'            if (_newLeafValue == 0) {'
libraries/TreeMath.sol, 88, b'                uint256 _idDepth1 = _id >> 16;'
libraries/TreeMath.sol, 92, b'                if (_newLeafValue == 0) {'
libraries/TreeMath.sol, 106, b'        return (_id >> 8, _id & 255);'
libraries/TreeMath.sol, 117, b'            return (_branchId << 8) + _leafId;'
libraries/TreeMath.sol, 117, b'            return (_branchId << 8) + _leafId;'
libraries/TreeMath.sol, 117, b'            return (_branchId << 8) + _leafId;'
libraries/SafeCast.sol, 15, b'        if ((y = uint248(x)) != x) revert SafeCast__Exceeds248Bits(x);'
libraries/SafeCast.sol, 22, b'        if ((y = uint240(x)) != x) revert SafeCast__Exceeds240Bits(x);'
libraries/SafeCast.sol, 29, b'        if ((y = uint232(x)) != x) revert SafeCast__Exceeds232Bits(x);'
libraries/SafeCast.sol, 36, b'        if ((y = uint224(x)) != x) revert SafeCast__Exceeds224Bits(x);'
libraries/SafeCast.sol, 43, b'        if ((y = uint216(x)) != x) revert SafeCast__Exceeds216Bits(x);'
libraries/SafeCast.sol, 50, b'        if ((y = uint208(x)) != x) revert SafeCast__Exceeds208Bits(x);'
libraries/SafeCast.sol, 57, b'        if ((y = uint200(x)) != x) revert SafeCast__Exceeds200Bits(x);'
libraries/SafeCast.sol, 64, b'        if ((y = uint192(x)) != x) revert SafeCast__Exceeds192Bits(x);'
libraries/SafeCast.sol, 71, b'        if ((y = uint184(x)) != x) revert SafeCast__Exceeds184Bits(x);'
libraries/SafeCast.sol, 78, b'        if ((y = uint176(x)) != x) revert SafeCast__Exceeds176Bits(x);'
libraries/SafeCast.sol, 85, b'        if ((y = uint168(x)) != x) revert SafeCast__Exceeds168Bits(x);'
libraries/SafeCast.sol, 92, b'        if ((y = uint160(x)) != x) revert SafeCast__Exceeds160Bits(x);'
libraries/SafeCast.sol, 99, b'        if ((y = uint152(x)) != x) revert SafeCast__Exceeds152Bits(x);'
libraries/SafeCast.sol, 106, b'        if ((y = uint144(x)) != x) revert SafeCast__Exceeds144Bits(x);'
libraries/SafeCast.sol, 113, b'        if ((y = uint136(x)) != x) revert SafeCast__Exceeds136Bits(x);'
libraries/SafeCast.sol, 120, b'        if ((y = uint128(x)) != x) revert SafeCast__Exceeds128Bits(x);'
libraries/SafeCast.sol, 127, b'        if ((y = uint120(x)) != x) revert SafeCast__Exceeds120Bits(x);'
libraries/SafeCast.sol, 134, b'        if ((y = uint112(x)) != x) revert SafeCast__Exceeds112Bits(x);'
libraries/SafeCast.sol, 141, b'        if ((y = uint104(x)) != x) revert SafeCast__Exceeds104Bits(x);'
libraries/SafeCast.sol, 148, b'        if ((y = uint96(x)) != x) revert SafeCast__Exceeds96Bits(x);'
libraries/SafeCast.sol, 155, b'        if ((y = uint88(x)) != x) revert SafeCast__Exceeds88Bits(x);'
libraries/SafeCast.sol, 162, b'        if ((y = uint80(x)) != x) revert SafeCast__Exceeds80Bits(x);'
libraries/SafeCast.sol, 169, b'        if ((y = uint72(x)) != x) revert SafeCast__Exceeds72Bits(x);'
libraries/SafeCast.sol, 176, b'        if ((y = uint64(x)) != x) revert SafeCast__Exceeds64Bits(x);'
libraries/SafeCast.sol, 183, b'        if ((y = uint56(x)) != x) revert SafeCast__Exceeds56Bits(x);'
libraries/SafeCast.sol, 190, b'        if ((y = uint48(x)) != x) revert SafeCast__Exceeds48Bits(x);'
libraries/SafeCast.sol, 197, b'        if ((y = uint40(x)) != x) revert SafeCast__Exceeds40Bits(x);'
libraries/SafeCast.sol, 204, b'        if ((y = uint32(x)) != x) revert SafeCast__Exceeds32Bits(x);'
libraries/SafeCast.sol, 211, b'        if ((y = uint24(x)) != x) revert SafeCast__Exceeds24Bits(x);'
libraries/SafeCast.sol, 218, b'        if ((y = uint16(x)) != x) revert SafeCast__Exceeds16Bits(x);'
libraries/SafeCast.sol, 225, b'        if ((y = uint8(x)) != x) revert SafeCast__Exceeds8Bits(x);'